CC := clang++
# CC := g++
LD := ld
AR := ar
AS := nasm
OBJCOPY := objcopy

# no-red-zone is needed because in kernel mode, the stack is nested due to interrupts not switching to a new stack
CFLAGS := -O2 -g -Wall -Wextra -m32 -march=i386 -ffreestanding -fbuiltin -fno-exceptions -fno-rtti -fno-omit-frame-pointer -fno-common -fno-pie -fcf-protection=none -fno-asynchronous-unwind-tables -mno-red-zone -std=c++20 -I .
LDFLAGS := -melf_i386 -nostdlib -no-pie -L/usr/lib/gcc/x86_64-linux-gnu/13/32 -lgcc

BOOTLOADER_OBJ := build/src/arch/x86/boot/boot.o
ARCH_OBJ := build/src/arch/x86/start32.o build/src/arch/x86/paging.o build/src/arch/x86/descriptors.o build/src/arch/x86/traps.o build/src/arch/x86/irq.o build/src/arch/x86/thread.o build/src/arch/x86/drv/hdd.o
KERNEL_OBJ := build/src/kernel/startup.o build/src/kernel/thread.o build/src/kernel/syscalls.o build/src/kernel/drv/basic.o
FREESTANDING_OBJ := build/src/freestanding/utils.o build/src/freestanding/demangle.o
LIBC_OBJ := build/src/libc/libc.o
INIT_OBJ := build/src/kernel/init.o

FIB_OBJ := build/src/apps/fib.o

ALL_OBJ := $(BOOTLOADER_OBJ) $(KERNEL_OBJ) $(FREESTANDING_OBJ) $(LIBC_OBJ) $(INIT_OBJ)

# Include dependency files
# This will include the dependency files generated by the depend.sh script
# and will ensure that any change to headers will force correct rebuilding.
# The wildcard function will expand to all .d files in the build directories
# are present, which prevents make from trying to generate .d files that
# don't exist.
include $(wildcard $(ALL_OBJ:.o=.d))

define _depend
#!/bin/sh
CC=$1
DIR=$2
shift 2
case "$DIR" in
"" | ".")
$CC -MM -MG -c "$@" | sed -e 's@^\(.*\).o:@\\1.d \\1.o:@g'
;;
*)
$CC -MM -MG -c "$@" | sed -e "s@^\(.*\).o:@$DIR\/\\1.d $DIR\/\\1.o:@g"
;;
esac
endef
export depend = $(value _depend)

.PRECIOUS: build/%.d

# Every file target in the build directory has a implicit dependency on the
# existence of the directory, as otherwise file creation would fail. This dependency
# however is only on its existence and not on the timestamp, so we use an ordered
# dependency.

build/%/:
	@mkdir -p $(@D)

build/depend.sh: Makefile | build/
	@echo "$$depend" > $@
	@chmod +x $@

.SECONDEXPANSION:
build/%.o: %.asm | $$(@D)/
	@echo Assembling $< 
	@$(AS) -f elf $< -o $@

.SECONDEXPANSION:
build/%.o: %.cpp build/%.d | $$(@D)/
	@echo Compiling $< 
	@$(CC) $(CFLAGS) -c $< -o $@

.SECONDEXPANSION:
build/%.d: %.cpp build/depend.sh | $$(@D)/
	@build/depend.sh $(CC) $(@D) $(CFLAGS) $< > $@

build/%.a:
	@echo Archiving $@
	@$(AR) rcs $@ $^

build/%.elf: %.ld 
	@echo Linking $@
	@$(LD) -T $<  $(filter-out $<, $^) -o $@ $(LDFLAGS)

%.bin: %.elf
	@echo Converting $< to binary
	@$(OBJCOPY) --remove-section .note* -O binary $< $@

%.map: %.elf
	nm -n $< > $@

%.md5: %
	@md5sum $< | xxd -r -p > $@

build/src/freestanding/freestanding.a: $(FREESTANDING_OBJ)

build/src/kernel/kernel.a: $(KERNEL_OBJ)

build/src/libc/libc.a: $(LIBC_OBJ)

build/src/arch/x86/boot/bootloader.elf: build/src/arch/x86/boot/mbr.o $(BOOTLOADER_OBJ) build/src/freestanding/freestanding.a

build/src/arch/x86/kernel.elf: build/src/arch/x86/entry.o $(ARCH_OBJ) build/src/kernel/kernel.a build/src/freestanding/freestanding.a

build/src/kernel/init.elf: build/src/libc/crt0.o $(INIT_OBJ) build/src/libc/libc.a build/src/freestanding/freestanding.a
	@$(LD) $^ -o $@ $(LDFLAGS)

build/src/apps/fib.elf: build/src/libc/crt0.o build/src/apps/fib.o build/src/libc/libc.a build/src/freestanding/freestanding.a
	@$(LD) $^ -o $@ $(LDFLAGS)

# tar is used to create a filesystem image, it naturally blocks files to 512 bytes which matches the sector size
build/fs.tar: build/src/arch/x86/boot/bootloader.bin build/src/arch/x86/kernel.bin.md5 build/src/arch/x86/kernel.bin build/src/arch/x86/kernel.map build/src/kernel/init.elf build/src/apps/fib.elf build/depend.sh
	@tar -cf $@ -C build $(^:build/%=%)

# the first file in the tar is the bootloader, so we need to skip the first 512 bytes which is the tar header for
# the bootloader so that the MBR is correctly filled with the first 512 bytes of bootloader.bin
# NOTE: tail is 1-indexed, so this strips the first 512 bytes
build/image: build/fs.tar
	@tail -c +513 $< > $@
	@truncate -s 16M $@

clean:
	@echo Cleaning up...
	@rm -rf build
